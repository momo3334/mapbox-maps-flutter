// Autogenerated from Pigeon (v22.6.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum PlaceAutocompleteType: Int {
  case country = 0
  case region = 1
  case postcode = 2
  case district = 3
  case place = 4
  case locality = 5
  case neighborhood = 6
  case street = 7
  case address = 8
}

enum _NavigationEventTypes: Int {
  case routeLineChanged = 0
}

/// Generated class from Pigeon that represents data sent in messages.
struct RouteProgressEventData {
  var distanceTraveled: Double
  var name: String



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RouteProgressEventData? {
    let distanceTraveled = pigeonVar_list[0] as! Double
    let name = pigeonVar_list[1] as! String

    return RouteProgressEventData(
      distanceTraveled: distanceTraveled,
      name: name
    )
  }
  func toList() -> [Any?] {
    return [
      distanceTraveled,
      name,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct GeoPoint {
  var type: String
  var coordinates: [Double]



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GeoPoint? {
    let type = pigeonVar_list[0] as! String
    let coordinates = pigeonVar_list[1] as! [Double]

    return GeoPoint(
      type: type,
      coordinates: coordinates
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      coordinates,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlaceAutoCompleteSuggestion {
  /// Place's name.
  var name: String
  /// Formatted address.
  var formattedAddress: String? = nil
  /// Place geographic point.
  var coordinate: GeoPoint? = nil
  /// List of points near [coordinate], that represents entries to associated building.
  var routablePoints: [RoutablePoint]? = nil
  /// [Maki](https://github.com/mapbox/maki/) icon name for the place.
  var makiIcon: String? = nil
  /// Distance in meters from place's coordinate to user location (if available).
  var distanceMeters: Double? = nil
  /// Estimated time of arrival (in minutes) based on the specified navigation profile.
  var etaMinutes: Double? = nil
  /// The type of result.
  var type: PlaceAutocompleteType
  ///Poi categories. Always empty for non-POI suggestions.
  var categories: [String]? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlaceAutoCompleteSuggestion? {
    let name = pigeonVar_list[0] as! String
    let formattedAddress: String? = nilOrValue(pigeonVar_list[1])
    let coordinate: GeoPoint? = nilOrValue(pigeonVar_list[2])
    let routablePoints: [RoutablePoint]? = nilOrValue(pigeonVar_list[3])
    let makiIcon: String? = nilOrValue(pigeonVar_list[4])
    let distanceMeters: Double? = nilOrValue(pigeonVar_list[5])
    let etaMinutes: Double? = nilOrValue(pigeonVar_list[6])
    let type = pigeonVar_list[7] as! PlaceAutocompleteType
    let categories: [String]? = nilOrValue(pigeonVar_list[8])

    return PlaceAutoCompleteSuggestion(
      name: name,
      formattedAddress: formattedAddress,
      coordinate: coordinate,
      routablePoints: routablePoints,
      makiIcon: makiIcon,
      distanceMeters: distanceMeters,
      etaMinutes: etaMinutes,
      type: type,
      categories: categories
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      formattedAddress,
      coordinate,
      routablePoints,
      makiIcon,
      distanceMeters,
      etaMinutes,
      type,
      categories,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct RoutablePoint {
  var point: GeoPoint
  var name: String



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RoutablePoint? {
    let point = pigeonVar_list[0] as! GeoPoint
    let name = pigeonVar_list[1] as! String

    return RoutablePoint(
      point: point,
      name: name
    )
  }
  func toList() -> [Any?] {
    return [
      point,
      name,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlaceAutocompleteResult {
  /// Result ID
  var id: String
  /// Result MapboxID
  var mapboxId: String? = nil
  /// Place's name.
  var name: String
  /// Place geographic point.
  var coordinate: GeoPoint
  /// List of points near [coordinate], that represents entries to associated building.
  var routablePoints: [RoutablePoint]? = nil
  /// [Maki](https://github.com/mapbox/maki/) icon name for the place.
  var makiIcon: String? = nil
  /// Distance in meters from place's coordinate to user location (if available).
  var distanceMeters: Double? = nil
  /// Estimated time of arrival (in minutes) based on the specified navigation profile.
  var etaMinutes: Double? = nil
  /// Place's address.
  /// The type of result.
  var type: PlaceAutocompleteType
  /// Poi categories. Always empty for non-POI results.
  /// @see type
  var categories: [String]? = nil
  /// Business phone number.
  var phone: String? = nil
  /// Business website.
  var website: String? = nil
  /// Number of reviews.
  var reviewCount: Int64? = nil
  /// Average rating.
  var averageRating: Double? = nil



  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlaceAutocompleteResult? {
    let id = pigeonVar_list[0] as! String
    let mapboxId: String? = nilOrValue(pigeonVar_list[1])
    let name = pigeonVar_list[2] as! String
    let coordinate = pigeonVar_list[3] as! GeoPoint
    let routablePoints: [RoutablePoint]? = nilOrValue(pigeonVar_list[4])
    let makiIcon: String? = nilOrValue(pigeonVar_list[5])
    let distanceMeters: Double? = nilOrValue(pigeonVar_list[6])
    let etaMinutes: Double? = nilOrValue(pigeonVar_list[7])
    let type = pigeonVar_list[8] as! PlaceAutocompleteType
    let categories: [String]? = nilOrValue(pigeonVar_list[9])
    let phone: String? = nilOrValue(pigeonVar_list[10])
    let website: String? = nilOrValue(pigeonVar_list[11])
    let reviewCount: Int64? = nilOrValue(pigeonVar_list[12])
    let averageRating: Double? = nilOrValue(pigeonVar_list[13])

    return PlaceAutocompleteResult(
      id: id,
      mapboxId: mapboxId,
      name: name,
      coordinate: coordinate,
      routablePoints: routablePoints,
      makiIcon: makiIcon,
      distanceMeters: distanceMeters,
      etaMinutes: etaMinutes,
      type: type,
      categories: categories,
      phone: phone,
      website: website,
      reviewCount: reviewCount,
      averageRating: averageRating
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      mapboxId,
      name,
      coordinate,
      routablePoints,
      makiIcon,
      distanceMeters,
      etaMinutes,
      type,
      categories,
      phone,
      website,
      reviewCount,
      averageRating,
    ]
  }
}

private class MessagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PlaceAutocompleteType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return _NavigationEventTypes(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      return RouteProgressEventData.fromList(self.readValue() as! [Any?])
    case 132:
      return GeoPoint.fromList(self.readValue() as! [Any?])
    case 133:
      return PlaceAutoCompleteSuggestion.fromList(self.readValue() as! [Any?])
    case 134:
      return RoutablePoint.fromList(self.readValue() as! [Any?])
    case 135:
      return PlaceAutocompleteResult.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MessagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PlaceAutocompleteType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? _NavigationEventTypes {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? RouteProgressEventData {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? GeoPoint {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? PlaceAutoCompleteSuggestion {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? RoutablePoint {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? PlaceAutocompleteResult {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MessagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MessagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MessagesPigeonCodecWriter(data: data)
  }
}

class MessagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MessagesPigeonCodec(readerWriter: MessagesPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _NavigationManager {
  func getHostLanguage() throws -> String
  func example() throws
  func setRoute(origin: GeoPoint, destination: GeoPoint) throws
  func setRouteById(routeId: String) throws
  func cancelRoute() throws
  func getNavigationSessionState() throws -> String
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _NavigationManagerSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `_NavigationManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _NavigationManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let getHostLanguageChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationManager.getHostLanguage\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHostLanguageChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getHostLanguage()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getHostLanguageChannel.setMessageHandler(nil)
    }
    let exampleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationManager.example\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exampleChannel.setMessageHandler { _, reply in
        do {
          try api.example()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      exampleChannel.setMessageHandler(nil)
    }
    let setRouteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationManager.setRoute\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setRouteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let originArg = args[0] as! GeoPoint
        let destinationArg = args[1] as! GeoPoint
        do {
          try api.setRoute(origin: originArg, destination: destinationArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setRouteChannel.setMessageHandler(nil)
    }
    let setRouteByIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationManager.setRouteById\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setRouteByIdChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let routeIdArg = args[0] as! String
        do {
          try api.setRouteById(routeId: routeIdArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setRouteByIdChannel.setMessageHandler(nil)
    }
    let cancelRouteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationManager.cancelRoute\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelRouteChannel.setMessageHandler { _, reply in
        do {
          try api.cancelRoute()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      cancelRouteChannel.setMessageHandler(nil)
    }
    let getNavigationSessionStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationManager.getNavigationSessionState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getNavigationSessionStateChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getNavigationSessionState()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getNavigationSessionStateChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _NavigationInstanceManager {
  func setupNavigationManager(channelSuffix: String) throws
  func tearDownNavigationManager(channelSuffix: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _NavigationInstanceManagerSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `_NavigationInstanceManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _NavigationInstanceManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setupNavigationManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationInstanceManager.setupNavigationManager\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setupNavigationManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.setupNavigationManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setupNavigationManagerChannel.setMessageHandler(nil)
    }
    let tearDownNavigationManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationInstanceManager.tearDownNavigationManager\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tearDownNavigationManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.tearDownNavigationManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tearDownNavigationManagerChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _NavigationCameraManager {
  func requestNavigationCameraToOverview() throws
  func requestNavigationCameraToFollowing() throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _NavigationCameraManagerSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `_NavigationCameraManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _NavigationCameraManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let requestNavigationCameraToOverviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationCameraManager.requestNavigationCameraToOverview\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestNavigationCameraToOverviewChannel.setMessageHandler { _, reply in
        do {
          try api.requestNavigationCameraToOverview()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      requestNavigationCameraToOverviewChannel.setMessageHandler(nil)
    }
    let requestNavigationCameraToFollowingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._NavigationCameraManager.requestNavigationCameraToFollowing\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestNavigationCameraToFollowingChannel.setMessageHandler { _, reply in
        do {
          try api.requestNavigationCameraToFollowing()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      requestNavigationCameraToFollowingChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _PlaceAutocompleteManager {
  func suggestions(query: String, completion: @escaping (Result<[PlaceAutoCompleteSuggestion], Error>) -> Void)
  func select(index: Int64, completion: @escaping (Result<PlaceAutocompleteResult?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _PlaceAutocompleteManagerSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `_PlaceAutocompleteManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _PlaceAutocompleteManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let suggestionsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PlaceAutocompleteManager.suggestions\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      suggestionsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let queryArg = args[0] as! String
        api.suggestions(query: queryArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      suggestionsChannel.setMessageHandler(nil)
    }
    let selectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PlaceAutocompleteManager.select\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      selectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let indexArg = args[0] as! Int64
        api.select(index: indexArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      selectChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol _PlaceAutocompleteInstanceManager {
  func setupPlaceAutocompleteManager(channelSuffix: String) throws
  func tearDownPlaceAutocompleteManager(channelSuffix: String) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class _PlaceAutocompleteInstanceManagerSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `_PlaceAutocompleteInstanceManager` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: _PlaceAutocompleteInstanceManager?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let setupPlaceAutocompleteManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PlaceAutocompleteInstanceManager.setupPlaceAutocompleteManager\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setupPlaceAutocompleteManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.setupPlaceAutocompleteManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setupPlaceAutocompleteManagerChannel.setMessageHandler(nil)
    }
    let tearDownPlaceAutocompleteManagerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.mapbox_maps_flutter._PlaceAutocompleteInstanceManager.tearDownPlaceAutocompleteManager\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      tearDownPlaceAutocompleteManagerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let channelSuffixArg = args[0] as! String
        do {
          try api.tearDownPlaceAutocompleteManager(channelSuffix: channelSuffixArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      tearDownPlaceAutocompleteManagerChannel.setMessageHandler(nil)
    }
  }
}
